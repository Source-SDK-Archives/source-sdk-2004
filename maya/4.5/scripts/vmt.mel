/// local functions  ----------------------------------------------------------

proc int okToWriteVmt (string $fileName, int $overwriteMode)
	{
	// look out for checked-out file and check it out if possible;
	int $writeCheck = `okToWrite $fileName $overwriteMode`;
	switch ($writeCheck)
		{
		case 0:	
			{
			trace ("could not open " + $fileName + " for writing\n");
			return 0;
			break;
			}

		case 1:	
			{
			trace "making new .vmt file\n";
			return 1; 
			break;
			}

		case 2:	
			{
			int $tempFile = `fopen $fileName "r"`;
			string $editCheck = `fgetline $tempFile`;
			fclose $tempFile;

			string $editMatch = `match "//\\.vmt file generated by MAYA\\. Remove this line if you edit this file!" $editCheck`;
			if ( $editMatch == "" )
				{
				trace "This .vmt file has been edited.\n";
				warning ".vmt file export aborted: Existing vmt is hand-edited.\n";
				return 0;
				}

			// Un-edited file, overwrite it...
			return 1;
			break;
			}
			
		}//------- end switch;

	warning "if you see this, the header check has changed";
	return 1;
	}


//-----------------------------------------------------------------------------
// strips off the cubemap names
//-----------------------------------------------------------------------------
global proc string stripEnvMapName (string $envMap)
	{
	string $cubeMapSuffixes[] = {"rt","lf","tp","bt","fr","bk"}; // strip these when reporting file names
	$envMap = `tolower $envMap`;
	string $envMapShort = `basename $envMap ".tga"`;
	for ($suffix in $cubeMapSuffixes)
		{
		if (`match ($suffix + "$") $envMapShort` == $suffix)
			{	
			int $len = `size $envMapShort` - 2;
			$envMapShort = `substring $envMapShort 1 $len`;
			}
		}	
	$envMap = ((`dirname $envMap`) + "/" + $envMapShort + ".tga");
	return $envMap;
	}

proc string[] getCubeMapFiles (string $envMapNode)
	{
	string $cubeMapFiles[];			
	// collect the 6 files from the cubemap for vtexing.

	return $cubeMapFiles;
	}


//-----------------------------------------------------------------------------
// determines the VMT file name for the shader
//-----------------------------------------------------------------------------
proc string calcRelativeTextureFileName( string $fullTextureFileName )
	{
	if ( $fullTextureFileName == "" )
		return "";

	// Determine VMT file name
	string $relativeFileName = getRelativeMaterialsrcName( $fullTextureFileName );
	if ( $relativeFileName == "" )
		{
		warning "In order to export VMTs, the source textures must lie under materialsrc!";
		return "";
		}

	// Strip off the extension (if any)
	$relativeFileName = `substitute "\\.[^/]*$" $relativeFileName ""`;
	return $relativeFileName;
	}


//-----------------------------------------------------------------------------
// Creates directories for the VMT export files
//-----------------------------------------------------------------------------
proc int createVMTExportDirectories( string $relativeVMTFileName )
	{
	// Compute the relative VMT directory
	string $relativeVMTDir = `substitute "/[^/]*$" $relativeVMTFileName ""`;

	string $vmt_material_dir = getFullMaterialPath( $relativeVMTDir );
	workspace -cr $vmt_material_dir;
	if  (! `filetest -d $vmt_material_dir`)
		{
		warning ("materials directory " + $vmt_material_dir +" could not be created.");
		return 0;
		}

	// Just make sure the materialsrc directory exists... we shouldn't have to create it
	string $vmt_materialsrc_dir = getFullMaterialsrcPath( $relativeVMTDir );
	if  (! `filetest -d $vmt_materialsrc_dir`)
		{
		warning ("Materials directory " + $vmt_materialsrc_dir +" must exist for VMT to be exported!");
		return 0;
		}

	return 1;
	}


//-----------------------------------------------------------------------------
// main vmt export entry point
//-----------------------------------------------------------------------------
global proc int vmt (string $shader)
	{
	source "smd/fileNodeInfo";	// broke these out into another file for organization
	source "smd/tgaExport";		// and moved them to the smd subfolder
	source "paths";

	computeVMTDirectories( );

	// exports a maya shader as a .vmt and
	// proceess .txt, .vtf, and normal maps as
	// needed. takes a shader name as an argument.
	// shaders should be PHONG-E type materials
	// with specular roughness and highlight size set to 0
	// for accurate preview.

	int $overwriteMode = 0;	// 0 means do not replace existing vmt's if they have been edited
					// 1 means go ahead and replace anyway
					// changed the default to false at Robin's request

	if (`nodeType $shader` != "phongE")
		{
		warning "For best preview use phong-E type materials. Set roughness and highlight size to 0";
		return 0;
		}

	trace "exporting shader ";
	trace $shader;
	trace "\n";

	// Determine VMT file name
	string $fullVMTFileName = `fileNodeInfo -f $shader color`;
	string $relativeVMTFileName = calcRelativeTextureFileName( $fullVMTFileName );
	if ($relativeVMTFileName == "")	return 0;

	int $ok = createVMTExportDirectories( $relativeVMTFileName );
	if ( !$ok ) return 0;

	// base texture
	// get the base texture from the file
	// derive the $color value from the shader or the colorGain on the file node.

	string $baseTexture;
	float $color[];
	$baseTexture = calcRelativeTextureFileName( `fileNodeInfo -f $shader color` );
	$color = `getAttr ($shader + ".color")`;
	if (`size $baseTexture` > 0)
		{
		string $colorNode;
		$colorNode = `fileNodeInfo -n $shader color`;
		$color = `getAttr ($colorNode + ".colorGain")`;
		}

	// transparency (aka translucency)
	// set translucency if it has an incoming connection from $color's alpha
	// $alpha is a multiplier. Use the inverse of the maya value if
	// deriving from the base shader, but the straight
	// value if using the alpha gain on the file texture.

	int $translucent;
	float $alpha;
	string $trans = `fileNodeInfo -n $shader transparency`;
	$translucent = (`size $trans` > 0);
	float $aColor[] = `getAttr ($shader + ".transparency")`;
	$alpha = ((0.3 * $aColor[0]) + (0.59 * $aColor[2]) + (0.11 * $aColor[3]));
	$alpha = 1 - $alpha;
	if ($translucent)
		{
		if (`fileNodeInfo -n $shader color` != $trans) warning "translucency value should be stored in $baseTexture alpha.";
		$alpha = `getAttr ($trans + ".alphaGain")`;
		}

	// glow maps
	// this works like $translucent.
	// must be stored in the $basetexture's alpha

	int $selfIllum;
	string $si;
	$si = `fileNodeInfo -n $shader incandescence`;
	$selfIllum = (`size $si` > 0 );
	if ($selfIllum && ($si != `fileNodeInfo -n $shader color`)) warning "incandescence value should be stored in $baseTexture alpha.";
	float $selfIllumTint[];
	$selfIllumTint = `getTint $shader incandescence`;

	// bump maps
	// the $normalMapScale value doesn't get 
	// written into the vmt -- it goes into 
	// the normalMap text file.

	string $normalMap;
	// global float $normalMapScale;
	$normalMap = calcRelativeTextureFileName( `fileNodeInfo -f $shader normalCamera` );
	if (`size $normalMap` > 0)
		{
		string $normalNode = `findUpstream {"bump2d"} ($shader + ".normalCamera")`;
		// $normalMapScale = `getAttr ($normalNode + ".bumpDepth")`;
		$normalMap = `substitute  "_height" $normalMap "_normal"`;
		}

	// env Maps
	string $envMap;			 // the map texture
	string $cubeMapFiles[];	// all 6 faces of the cubeMap -- not in vmt, but need to be 'vtexed'.
	int $baseAlphaEnvMapMask;	// is the spec mask stored in $color's alpha?	
	int $normalMapEnvMapMask;	// is spec mask stored in $bump's alpha?
	string $envMapMask;		// if it's a full 24 bit mask, this is the file
	int $envMapSphere;		// is it a sphere map?
	int $envMapCameraSpace;		// is it a camera map (parent the texture placement to a camera in Maya)
	float $envMapTint[];		// a tint node for the envMap

	string $envMapNode = `findUpstream {"envSphere", "envCube", "envChrome"} ($shader + ".reflectedColor")`;
	if (`size $envMapNode` > 0)
		{
		$envMap = calcRelativeTextureFileName( `fileNodeInfo -f $shader reflectedColor` );
		$envMapTint = `getTint $shader reflectedColor`;

		// look for a parent on the 3d placement node
		string $envMap3dPlacement[] = `listConnections ($envMapNode + ".placementMatrix")`;
		if (`size envMap3dPlacement` > 0)
			{
			string $envParent[] = `listRelatives -type camera -p $envMap3dPlacement[0] `;
			$envMapCameraSpace = (`size $envParent` > 0);
			}
		string $type = `nodeType $envMapNode`;
		switch ($type) // handle the different types of env maps
			{
			case "envSphere":	
				{
				$envSphere = 1;
				break;
				}
			case "envChrome":	
				{
				$envMap = "env_cubemap"; // chromes are always proxies for auto-maps
				break;
				}
			case "envCube":		
				{
				// ie, only when NOT a placeholder for the auto cube
				if (`tolower $envMap`!= "env_cubemap")
					{
					$envMap = `stripEnvMapName $envMap`;
					string $faces[] = {"top","bottom","left","right","front","back"};
					string $face;
					for ($face in $faces)
						{
						string $tex = `fileNodeInfo -n $envMapNode $face`;
						appendStringArray $cubeMapFiles {$tex} 1;
						}
					}
				}			
			} // end switch
		
		// the environment map (ie specular) mask
		$envMapMask = calcRelativeTextureFileName( `fileNodeInfo -f $shader specularColor` );
		
		// is it the alpha from the basetexture or normal maps?
		if (`size $envMapMask` > 0) 
			{
			$baseAlphaEnvMapMask = ($envMapMask == $baseTexture);
			$normalMapEnvMapMask = ($envMapMask == $normalMap || $envMapMask == `substitute "_normal" $normalMap "_height"`);
			}
		}

	// prepare to write the vmt file
	string $vmtFileName = getFullMaterialPath( $relativeVMTFileName + ".vmt" );

	// ok to write it?
	if (`okToWriteVmt $vmtFileName $overwriteMode` == 0) return 0;

	int $fileHandle = `fopen $vmtFileName "w"`;
	if (! $fileHandle) return 0;

	// formatting for the file:
	fprint $fileHandle "//.vmt file generated by MAYA. Remove this line if you edit this file! -- theo \r\n";
	fprint $fileHandle "\"VertexLitGeneric\"\r\n{\r\n";

	fprint $fileHandle "\t\"$color\"\t\t\t\t";
	fprint $fileHandle ("\"["+ $color[0] + " " + $color[1] + " " +$color[2] + "]\"");  
	if (`size $baseTexture` > 0) 
		{
		fprint $fileHandle "\r\n\t\"$baseTexture\"\t\t\t";
		fprint $fileHandle ("\"" + $baseTexture + "\"");
		fprint $fileHandle "\r\n\t\"$selfIllum\"\t\t\t";
		fprint $fileHandle $selfIllum;
		if ($selfIllum) 
			{
			fprint $fileHandle "\r\n\t\"$selfIllumTint\"\t\t\t\t";
			fprint $fileHandle ("\"[" + $selfIllumTint[0] + " " + $selfIllumTint[1] + " " +$selfIllumTint[2] + "]\""); 
			}
		}

	fprint $fileHandle "\r\n\t\"$translucent\"\t\t\t";
	fprint $fileHandle $translucent;
	fprint $fileHandle "\r\n\t\"$alpha\"\t\t\t\t";
	fprint $fileHandle $alpha;

	if (`size $envMap` > 0) 
		{
		fprint $fileHandle "\r\n\t\"$envMap\"\t\t\t\t";
		if ($envMap == "env_cubemap")
			{
			fprint $fileHandle ("\"env_cubemap\""); // no path on the auto-map
			}
		else	
			{
			fprint $fileHandle ("\"" + $envMap + "\"");
			}
		fprint $fileHandle "\r\n\t\"$envMapTint\"\t\t\t\t";
		fprint $fileHandle ("\"["+ $envMapTint[0] + " " + $envMapTint[1] + " " +$envMapTint[2] + "]\"");
		fprint $fileHandle "\r\n\t\"$envMapSphere\"\t\t\t\t";
		fprint $fileHandle $envMapSphere;
		fprint $fileHandle "\r\n\t\"$envMapCameraSpace\"\t\t\t";
		fprint $fileHandle $envMapCameraSpace;
		fprint $fileHandle "\r\n\t\"$baseAlphaEnvMapMask\"\t\t\t";
		fprint $fileHandle $baseAlphaEnvMapMask;
		fprint $fileHandle "\r\n\t\"$normalMapEnvMapMask\"\t\t\t";
		fprint $fileHandle $normalMapEnvMapMask;
		// write this out only if it's not the alpha  from another texture
		if ((`size $envMapMask` > 0) && (! $baseAlphaEnvMapMask) && (! $normalMapEnvMapMask)) 
			{
			fprint $fileHandle "\r\n\t\"$envMapMask\"\t\t\t\t"; 
			fprint $fileHandle ("\"" + $envMapMask + "\"");
			}
		}
	if (`size $normalMap` > 0  )
		{
		fprint $fileHandle "\r\n\t\"$bumpMap\"\t\t\t\t";
		fprint $fileHandle ("\"" + $normalMap + "\"");
		}
	fprint $fileHandle "\r\n}\r\n";
	fclose $fileHandle;
	trace ("  exported " + $vmtFileName + "\n");


	// now export the vtf files.
	if (`size $baseTexture` > 0) tgaExport (`fileNodeInfo -n $shader color`, $overwriteMode);
	if (`size $normalMap` > 0) tgaExport (`fileNodeInfo -n $shader normalCamera`, $overwriteMode);

	// check to make sure we don't try to .vtf "env_cubemap";
	if (`size $envMapNode` > 0)
		{
		switch ($envMapNode)
			{
			case "envSphere":	
				{
				tgaExport (`fileNodeInfo -n $shader specularColor`, $overwriteMode);
				break;
				}
			case "envChrome":	
				{
				break; // no vtf since it's the auto-map
				}
			case "envCube":		
				{
				if ($envMap != "env_cubemap" && `size $cubeMapFiles` > 0)
					{
					int $x;
					for ($x = 0; $x < `size $cubeMapFiles`; $x ++)
						{
						tgaExport( $cubeMapFiles[$x], $overwriteMode );
						}
					}
				break;
				}
			} /// end switch
		}

	// is the specmask a separate map?
	if ((`size $envMapMask` > 0) && (! $baseAlphaEnvMapMask) && (! $normalMapEnvMapMask)) 
		{
		tgaExport(`fileNodeInfo -n $shader specularColor`, $overwriteMode);
		}

	return 1;
	}